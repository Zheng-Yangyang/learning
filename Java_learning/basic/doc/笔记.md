这篇笔记主要记录学习Java基础是遇到的语法问题和解决方案

首先我的学习环境是`IntelliJ IDEA 2021.3.3`，使用的`Java`版本是$jdk11$

#### 1.包名

我开始写的时候，本来是准备$01$包名这种的，但是发现始终会出错，发现不能直接用数字作为包名，然后就学习了一下包的命名规范

Java 中的包命名规范通常遵循以下几个原则：

1. **小写字母**：包名应该使用小写字母，这是 Java 编程约定的一部分，符合 Java 代码的风格规范。
2. **反向域名**：通常，包名采用反向的域名形式。这意味着你应该从域名开始，然后逆序编写域名的组件作为包名。例如，如果你的域名是 `example.com`，那么相应的包名应该是 `com.example`。
3. **唯一性**：包名应该是唯一的。确保你的包名与其他项目中的包名不冲突，以避免潜在的命名冲突。
4. **简洁性**：包名应该简洁而具有描述性。尽量使用简短、明确的名称来表示包所包含的内容。
5. **避免使用 Java 关键字**：避免使用 Java 关键字或保留字作为包名，以免造成混淆和不必要的麻烦。
6. **避免使用连字符**：虽然连字符（减号）在包名中是合法的，但通常不建议使用。使用连字符可能会导致一些问题，例如导入和包引用时的混淆。
7. **采用语义化的名称**：包名应该具有一定的语义，以便开发者能够根据包名直观地理解其所包含的内容。避免使用过于抽象或不相关的名称。

总的来说，包名的命名规范有助于组织和管理 Java 代码，使其更加清晰、可维护和易于理解。符合命名规范可以提高代码的可读性，并促进团队合作和代码复用。

除此之外，每个代码前面都需要写上对应的包名，比如下面这个

```java
package p_01;
public class test {

    public static void main(String[] args) {
        System.out.println("150");
    }
}
```

不然会报下面的错误

```shell
Missing package statement: 'p_01' 
```

关于包声明：

包声明语句用于指定该文件中的类属于哪个包。这是因为 Java 采用了包（Package）机制来组织和管理代码，以避免类名的冲突，并提供了更好的代码结构和管理。因此，包名的声明在 Java 中是一个很重要的部分。

包声明语句的作用包括：

1. **命名空间管理**：包声明确保了每个类的全名是唯一的。这样做可以防止不同的类之间发生名称冲突，即使它们具有相同的类名也不会产生问题，因为它们属于不同的包。
2. **可见性控制**：Java 中的访问控制是基于包的。如果类的成员没有指定访问修饰符，它们将默认为包私有（即只能在同一个包内访问）。因此，包声明也决定了类的成员的可见性范围。
3. **包级别访问控制**：Java 中的包级别访问控制意味着默认访问级别（包私有）的类和成员对于同一个包内的其他类是可见的，但对于其他包是不可见的。因此，包声明语句还确定了该文件中的类和成员是否可以被其他包中的类访问。
4. **组织代码**：包声明语句有助于组织和结构化代码。它提供了一种将相关的类和接口组织在一起的方式，使代码更易于维护和理解。

综上所述，包声明语句是 Java 中的一个重要组成部分，它确保了代码的命名空间管理、访问控制和组织结构，提高了代码的模块化性和可维护性。

#### 2.数据类型

| 数据类型 | 关键字  | 内存占用 |                 取值范围                  |
| :------: | :-----: | :------: | :---------------------------------------: |
|   整数   |  byte   |    1     |    负的2的7次方 ~ 2的7次方-1(-128~127)    |
|          |  short  |    2     | 负的2的15次方 ~ 2的15次方-1(-32768~32767) |
|          |   int   |    4     |        负的2的31次方 ~ 2的31次方-1        |
|          |  long   |    8     |        负的2的63次方 ~ 2的63次方-1        |
|  浮点数  |  float  |    4     |        1.401298e-45 ~ 3.402823e+38        |
|          | double  |    8     |      4.9000000e-324 ~ 1.797693e+308       |
|   字符   |  char   |    2     |                  0-65535                  |
|   布尔   | boolean |    1     |                true，false                |

```java
package p_01;
public class test {

    public static void main(String[] args) {
        int a = 10;
        byte b = (byte) 128; // 这个b变成了-128，因为被截断了
        char c = 782;  // Java的char类型是使用Unicode编码的，所以很多数字都对应字符，并且前面的字符对应的是ascill字符
        System.out.println(c);
        long d = 2222; //如果只声明，没有初始化会出错
        // System.out.println(d);
        double e = 5e+38; //会输出5.0e38
        System.out.println(e);
        boolean flag = true;
        System.out.println(flag);
    }
}
```

#### 3.反射

Java的反射（Reflection）是指在程序运行时，能够获取类的信息、调用类的方法、访问或修改类的属性等操作的机制。通过反射，可以在运行时检查类、构造类实例、调用类方法、访问或修改类成员变量，而无需在编译时确定这些操作。

Java的反射机制主要由以下几个核心类和接口组成：

1. **Class类**：java.lang.Class类是反射机制的核心，它代表了Java中的类和接口。通过Class类可以获取类的信息，如类名、父类、实现的接口、类的修饰符等。可以通过`Class.forName("className")`方法或`.class`属性来获取类的Class对象。
2. **Constructor类**：java.lang.reflect.Constructor类用于描述类的构造方法。通过Constructor类可以创建新的对象实例。
3. **Method类**：java.lang.reflect.Method类用于描述类的方法。通过Method类可以调用类的方法。
4. **Field类**：java.lang.reflect.Field类用于描述类的成员变量。通过Field类可以访问和修改类的成员变量。

反射机制的常见用途包括：

- 在运行时动态加载类
- 在运行时获取类的信息，如类名、方法、属性等
- 在运行时调用类的方法
- 实现通用的框架，如JUnit、Spring等，通过反射可以实现通用的功能，减少重复代码的编写

反射虽然提供了很大的灵活性，但由于其运行时的特性，会带来一定的性能开销，并且使代码更加复杂。因此，在使用反射时需要权衡灵活性和性能，并谨慎使用。


在Java语言中，获取Class对象有三种主要的方式：

1. **使用.class语法**： 这是最简单、最常见的方式，即通过已知类的名称直接在代码中使用`.class`语法获取该类的Class对象。例如：

   ```java
   javaCopy code
   Class<?> clazz = MyClass.class;
   ```

2. **调用对象的getClass()方法**： 如果已经有了对象的实例，可以通过调用该实例的`getClass()`方法来获取其对应的Class对象。例如：

   ```java
   javaCopy codeMyClass obj = new MyClass();
   Class<?> clazz = obj.getClass();
   ```

3. **使用Class.forName()方法**： 如果只知道类的名称（全限定名），可以使用`Class.forName()`方法来加载该类，并获取其对应的Class对象。例如：

   ```java
   javaCopy codetry {
       Class<?> clazz = Class.forName("com.example.MyClass");
   } catch (ClassNotFoundException e) {
       e.printStackTrace();
   }
   ```

这三种方式都能够获取到同一个Class对象，但在不同的场景下有不同的使用情况。`.class`方式在编译时就确定了，适合已知类的情况；`getClass()`方法适合已经有对象实例的情况下获取其Class对象；`Class.forName()`方法适合根据类名字符串动态加载类的情况。
